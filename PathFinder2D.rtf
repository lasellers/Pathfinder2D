{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\fnil\fprq2\fcharset2 Wingdings;}}
{\colortbl ;\red0\green0\blue255;}
{\stylesheet{ Normal;}{\s1 heading 1;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\brdrl\brdrdash\brdrw60\brsp80 \brdrt\brdrdash\brdrw60\brsp20 \brdrr\brdrdash\brdrw60\brsp80 \brdrb\brdrdash\brdrw60\brsp20 \nowidctlpar\s1\sb280\sa10\b\f0\fs28 $#KPathFinder2D v1.28 FINAL August 2012\par
\pard\b0\fs24 By Lewis Sellers (aka Min)\par
\b Intrafoundation Software\par
\b0{\field{\*\fldinst{HYPERLINK "http://www.intrafoundation.com/pathfinder2d.asp"}}{\fldrslt{\ul\cf1 http://www.intrafoundation.com\cf1\ul /pathfinder2d.asp}}}\f0\fs24\par
\cf0\ulnone\par
PathFinder2D is an open-source experiment in various 2D shortest-path algorithms and techniques. Primary conversation about this software occurs in the newsgroup \cf1\ul{\field{\*\fldinst{HYPERLINK "news://comp.ai.games/"}}{\fldrslt{news://comp.ai.games}}}\cf0\ulnone\f0\fs24 .\par
\par
This software was written in C++ using MSVC++ 6 Professional SP5 + MS Platform SDK.\par
\par
All references to the timings of a \ldblquote test\rdblquote  machine refer to an old Athlon 1.1ghz with 32/32kb L1 and 256kb L2 cache.\par
\par
This software was improved with the chatty help of:\par
\pard\li720\i Eternal Vigilance\par
Michael Horsch\par
Dmitriy Iassenev \par
Randolph M. Jones \par
Amit Patel\par
Justin Heyes-Jones\par
Steven Woodcock\i0  (\cf1\ul{\field{\*\fldinst{HYPERLINK "http://www.gameai.com"}}{\fldrslt{\ul\cf1 http://www.gameai.com}}}\cf0\ulnone\f0\fs24 )\i\par
\pard\i0\par
New v1.16 maze examples generated by Daedalus 1.3 created by Walter D. Pullen - {\field{\*\fldinst{HYPERLINK "http://www.astrolog.org/labyrnth/maze.htm"}}{\fldrslt{\ul\cf1 http://www.astrolog.org/labyrnth/maze.htm}}}\f0\fs24 .\par
\par
NOTE: If you notice ANY bugs in this software (either observationally or in the source code) feel free to email. One of the ideas behind this software is to provide a set of reference examples to test production game code against. And to do that the code must be as accurate and bug free as possible.\par
\par
\pard\li720 Thanks,\par
\b\i --min\par
\pard\b0\i0\par
\uldb Version History\ulnone\v VERSION_HISTORY\v0\par
\par
\b The Algorithms:\par
\b0\par
\uldb Development\ulnone\v DEVELOPMENT\v0\par
\uldb A* Heap Integer No Closed (v4)\ulnone\v ASTAR\v0\par
\uldb A* Heap Integer (v3i)\ulnone\v ASTAR_HEAPINTEGER\v0\par
\uldb A* Heap (v3)\ulnone\v ASTAR_HEAP\v0\par
\uldb A* Complete (v2c)\ulnone\v ASTAR_COMPLETE\v0\par
\uldb A* Linked-list (v2)\ulnone\v ASTAR_LINKEDLIST\v0\par
\uldb A* Array (v1)\ulnone\v ASTAR_ARRAY\v0\par
\uldb Dijkstra\ulnone\v DIJKSTRA\v0\par
\uldb Breadth-First Search\ulnone\v BREADTH_FIRST\v0\par
\uldb Best-First Search\ulnone\v BEST_FIRST\v0\par
\uldb Depth-First Search\ulnone\v DEPTH_FIRST\v0\par
\uldb D*\ulnone\v DSTAR\v0\par
\uldb Right-Hand Rule\ulnone\v RIGHTHANDRULE\v0\par
\par
\b Notes:\par
\uldb\b0 Presearch\ulnone\v PRESEARCH\v0\par
\uldb Editing the graphics files\ulnone\v EDITING\v0\par
\uldb Selecting new start/end points\ulnone\v SELECTING_STARTEND_POINTS\v0\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page\super $#K\nosupersub Version History\par
\pard\fs24\par
v1.28 Final \b0 August 2012. Recompiled both 64-bit and 32-bit versions.\par
\b\par
v1.27 Final \b0 November 2004. Cleaned up files and re-released with installation software.\par
\b\par
v1.26 Final \b0 June 2004. Slight update to the code-base. Added a Zig-Zag pattern. Misc cleanup. Recompile. Hm. Oh, for 1.26 I reversed the colors of the starting and ending points. Seems more natural for green to be GO/START and red to be STOP/END. Removed the OpenGL code from project as the (as yet) unfinished Patherfinder3D project more properly makes use of complicated 3D code. (Seems the 2D version should be as simple as possible as far as the graphics interface it uses. K.I.S.S. etc.) This might actually be the final version this time unless you, the reader, happen to find a bug or want to add more test patterns or PathFinding Algorithms you\rquote ve coded to this code-base.\par
\par
I hope this source-code has been of use to any of you struggling to optimize the path-finding routines of your commercial (or otherwise) game projects.\par
Thank you.\par
\par
--Lewis Sellers. A.K.A. \ldblquote Min\rdblquote\par
June 2004.\par
\b v1.25\b0  ? Not sure what changes we made to 1.25 as it wasn\rquote t logged. Presumably the OpenGL 3D code.\par
\b v1.24\b0\tab July 19\super th\nosupersub  2003-07-19\tab Started to add some OpenGL animation code. For the future there are basically 7 areas of improvement for PathFinder2D:\par
\pard\fi-360\li720\tx720 1)\tab Completing/Expanding the 3d animation code.\par
\pard\fi-360\li720 2)\tab Adding as many shortest-path algorithms as exist for 2d maps\par
3)\tab Improving the code for all classes of this program\par
\pard\fi-360\li720\tx720 4)\tab Adding option to change map size to 16x16,32x32,64x64,128x128,256x256 or 512x512. (Means making all algs use new/delete for world maps).\par
\pard\fi-360\li720 5)\tab Adding option to use multilayer maps\par
6)\tab Maybe adding in a Daedulas-like maze generator or two for testing purposes :--)\par
7)\tab Adding proper algorithm descriptions to the help file.\par
\pard\b v1.23 Final\b0\tab Added Best-First. Cleaned up various other things including menus. Considered making help CHMs. Cleaned up maps and added more Daedalus maze maps. Fixed a lockup bug that could happen with Dijkstra\rquote s paint function when you changed start positions.\par
\b v1.22 Final\b0\tab Pathfinder2D was listed on gameai.com. Because of this I promoted the dev version of A* v4 to it\rquote s own Alg class, so that anyone wanting to experiment with their own variants can simply use the \ldblquote development\rdblquote  algorithm class.\par
Have a map that crashes pathfinder? Send it in.\par
Added Gates Maze to explore effects of large number of open nodes. A* v3 and v4 are perhaps a little too eager to find the best route and can tend to wander erratically. Hm.\par
\b v1.21 Final\b0\tab Less bugs. \f1 J\f0  Mainly in linked list A*. Stay tuned for PathFinder3D. ;-)\par
\b v1.20 Final\tab\b0 Added \ldblquote presearch\rdblquote  to avoid pathing when there is no path. Aside from possible bug fixes and user contributions (don\rquote t be shy) this is probably going to be the last update to this software for a long time. I\rquote ve done what I wanted to do with it.\par
\b v1.19\b0  July 8\super th\nosupersub  2003, early morning.\tab Final minor cleanup.\par
\b v1.18\b0  July 6\super th\nosupersub  2003\tab  Combined A* _WORLD and _NODES into one data structure for v4 of A*. Straightened up help file.\par
\b v1.17 \b0 July 6\super th\nosupersub  2003\tab  DEBUG12 16.7ms. Removed linked-lists from A* v3 as performs several other small optimizations. Getting hard to get any more ms now.\par
\b v1.16\b0\tab July 5\super th\nosupersub  2003\tab  DEBUG12 18.3ms. Lots of cleanup in all classes. Changed TGA load/save to inverse the data so it appears the same intensity scale in a graphics editor. TGA load can also now handle upside-down TGAs. After mulling it over finally changed the multi-AI pathing function around to a more cache-friendly FIFO priority queue system (it used to do them all simultaneously.) The newest A* is fast enough now that worrying about a few complex paths bogging down everything else isn\rquote t as great as a concern now.\par
\b v1.15\b0\tab July 4\super th\nosupersub  2003. Stabilized the buggy 1.14 version. DEBUG1 is now DEBUG12. DEBUG12 20.9ms. \par
\b v1.14\tab\b0 Reworked most everything. A* finally works correctly (albeit slightly slower now). Because of the reworking of the path-finding algorithms all previous mentioned timings are now invalid for comparison.\par
\b v1.12-1.13\b0\tab Unreleased.\par
\b v1.11 Final\par
v1.8 - 1.10\b0\tab  Bugs. Added DrawMode. Cut A* speed by another 1/3.\par
\b v1.7\b0\tab Added new A* using double linked-lists. Runs in 1/3 time of old implementation. Major class changes to make adding new algs easier.\par
\b v1.6\b0\tab A* seems "fixed" with a weight of 1.0. Hm. Also changed Dijkstra to linked-list, which made it about exactly 50x faster. One of these days I'll make A* linked-list too. (See _AStar.cpp). Few more suggestions by Eternal on comp.ai.games.\par
\b v1.5\b0\tab Added BFS. Fixed Dijkstra. Moved "common" functions to Algorithm.cpp. Changed BFS to have overlapping FIFO buffer for speed. A* still doesn't exactly work right.\par
\b v1.4\b0\tab Changed name from AStar to PathFinder. Added Dijkstra.\par
\b v1.3\b0\tab Reworked to do faster add/deletes. Still needs a sorted list for finding best f. Added high-resolution performance counter by suggestion of Eternal Vigilance. Also various tweak suggestions by Michael Horsch and Justin Heyes-Jones from comp.ai.games.\par
\b v1.2\b0\tab Minor debuggings + (fairly) significant speed optimizations.\par
\b v1.1\b0\tab Fixed many, many bugs. Added timers, etc.\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page\b0 $#KA* Development\par
\pard\fs24\par
The \ldblquote development\rdblquote  algorithm is a place reserved for me (and other people) to play around with experimental twists on shortest-path algorithms. Once it stabilizes it gets promoted to its own category. If you implemented a new shortest-path algorithm here (or new variant on one) feel free to send it (and documentation fit for a HLP file) to webmaster@intrafoundation.com.\par
\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page\b0 $#KA* Heap Integer No Closed (version 4)\par
\pard\b\fs24\par
\pard\li720\qj v 4. \b0\i combined _WORLD and _NODES into a single data structure.\par
\pard\i0\par
The 4\super th\nosupersub  version of A* that is currently under development is completing DEBUG12 in 11.96ms. Version 4 was originally based on the integer version of \ldblquote A* Heap Integer\rdblquote  (ie, 3bi). The main problem with 3bi is it was very unfriendly to the both L1 and L2 caches. V4 is an attempt to solve this by rearranging the data structure on which A* operates.\par
\par
We tried to address problems with the large data structure by combining _WORLD and _NODE structures into one. This had several benefits, but an odd outcome of this strategy is that now the \ldblquote node\rdblquote  and it\rquote s \ldblquote yx\rdblquote  coordinate are the same thing. When you specify a y/x address you also implicitly know its node number and visa-versa.\par
\par
F + g are now kept in the heap structure and exist only so long as the open node itself does. One result of this is that there is very little data left to turn into \ldblquote pretty graphics\rdblquote . This also means the memory footprint of v4 is considerably smaller than v3 and currently fits completely within the 256kb L2 cache.\par
\par
V4 unlike all other algorithms uses a fixed \ldblquote Manhattan\rdblquote  distance metric (as V4 is mean to be close to \ldblquote production\rdblquote  code we decided to choose the best and go with it)\par
\par
For V4 anything that can be done to make the code fast, stable and suitable for production is on the table.\par
\par
Frankly, at this point I\rquote m somewhat out of ideas on how to make it any faster without dropping down to assembly.\par
\par
todo v1.20\par
! if leaf>=max_leafs remove last leaf, then add new leaf\par
? presearch for all no-paths and mark as permantly_no_path if start/end there\par
!! consider delayed queuing if f over best_f*e (or n-nodes) to prevent heaps with levels greater than x (say 5 to 7). Ie, above level n is sort-delayed everything else.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page\b0 $# K A* Heap Integer (version 3bi)\par
\pard\fs24\par
\pard\li720\qj\b v 3bi.\b0  Changed from float to integer\i\par
\pard\i0\par
Version 3bi, ie \ldblquote A* Heap Integer\rdblquote  (released in Pathfinder v1.18) is essentially the same as 3b, ie \ldblquote A* Heap\rdblquote . The only difference is that all float operations were converted to integer. The net positive effect is a few ms speedup. The downside is that (currently) fractional costs are not accumulated thus making the path-finding somewhat less accurate.\par
\par
A particular note is that turning on 1.4 diagonals currently have no effect. (This may be addressed in the future).\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page\b0 $# K A* Heap (version 3b)\par
\pard\fs24\par
\pard\li720\qj\b v 3b.\b0\i  removed all trace of linked-lists.\par
\b\i0 V 3a.\b0\i  added heaps to v2 linked-list code.\par
\pard\i0\par
The 3\super rd\nosupersub  implementation of the A* (A-Star) path-finding algorithm. This version is theoretically about as fast as it is possible to make it algorithmically. That is not to say that the code structure itself can not be further optimized.\par
\par
For v1.14 (3a) what was created used a linked-list structure similar to V2 but sort-insertions were speeded up by using a priority queue \ldblquote heap\rdblquote . Initially the correctly working version was completing in about 26ms for DEBUG12 on the test machine. Next version (1.115) was doing 20.9ms. That same day v1.16 was completing in 18.3ms.\par
\par
In version v1.17 all references to linked-lists were removed as they now served no purpose that the heap was not already fulfilling. This only gained a few ms increase in speed because of the cache-miss problems associated with the large data structures.\par
\par
And, before you ask, the ROUTES graphic is supposed to look like that. It uses a technique generally called a \ldblquote dirty rectangle\rdblquote  to avoid having to clear the routing information when a new path is solved. This, theoretically, saves a few milliseconds.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $#K A* Complete\par
\pard\b0\fs24\par
This is essentially the same as the v2 linked-list A* algorithm except that it keeps it\rquote s CLOSED nodes available to test against for better path data. Slower than general A*.\par
\par
[currently unfinished. want to finish it? feel free to complete the code and submit a description for this hlp file.]\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K BFS Breadth-First Search\par
\pard\b0\fs24\par
One of the simplest path-finding algorithms there is, BFS is rather slow, but consistently so.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K Best-First Search\par
\pard\b0\fs24\par
Slightly more complex than Breadth-first or Depth-first, uses a distance heuristic to guide it to the goal.\par
\par
The implementation introduced with PathFinder2D v1.23 was hacked together in half an hour using the heap version of A*.\par
\par
\b Version History:\par
\pard\fi720\b0 Added v1.23. Based on A* Heap version.\par
\pard\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K Depth-First Search\par
\pard\b0\fs24\par
[unimplemented]\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K Dijkstra\par
\pard\b0\fs24\par
This is an implementation of Dijkstra\rquote s algorithm using only OPEN nodes. Could be faster, but it\rquote s not bad as is.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K Right-Hand Rule\par
\pard\b0\fs24\par
[unimplemented]\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K D* (Dynamic A*)\par
\pard\b0\fs24\par
[unimplemented]\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $ # K A* Linked-list (version 2)\par
\pard\b0\fs24\par
The second attempt at A* uses linked lists and inserts nodes in order as they are added.\par
\par
Originally it was decently fast at about 32ms using DEBUG12 on the test machine. However, it was giving slightly suboptimal results (nothing major as the only people who would notice would be your various path-finding experts) so I finally tracked down the bug and fixed it. Well\'85 now it runs properly, but three times slower at around 90ms. Now, if it hadn\rquote t been that I\rquote d already started on an even faster version using heaps I would have seriously had to consider just leaving it slightly buggy but 3x faster.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page $#KA* Arrays (version 1)\par
\pard\b0\fs24\par
The very first attempt at an A* algorithm, it uses a simple static array to store node data. It is very slow. DEBUG12 completed in about 330ms on the test machine for the major version 1.11. Come the next release v1.14 however where most the algorithms were corrected it was running around 357ms. For v1.16 while fixing a bug with the pipe maze rendering, saw a few very obvious (now) ways to speedup the path-finding, so now the array version runs in 215ms.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page #$K Editing the graphic files\par
\pard\b0\fs24\par
Aside from a few internally generated test graphics, PathFinder2D gets all it\rquote s map data from TARGA (ie, TGA) graphics files. All these files are 256x256 256 color TARGAs. They software can load either compressed or uncompressed files of either top-to-bottom or bottom-to-top varieties.\par
\par
The loader itself converts them into the internal terrain representation that it uses, which is simply the numeric range 0 to 15 (ie, reduces them to 16-color grayscale). Internally, 0 is considered to have no cost weight at all, while 15 is impassable. Generally 0 is not used except in special occasion. For \ldblquote paved roads\rdblquote  etc you would use 1.\par
\par
When creating these TGA images in external paint programs as 256-shade grayscale images this ordering is inversed: 0 to 15 are considered to be impassable terrain. Scales of 240 and above have no weight at all.\par
\par
NOTE: PathFinder has its own internal editor now.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page #$K Selecting new start/end points\par
\pard\b0\fs24\par
To change the start and end points, simply press the LEFT mouse button where you want the starting (GREEN) point to be and the RIGHT mouse button to place the (RED) goal point.\par
\par
\pard\brdrl\brdrs\brdrw10\brsp80 \brdrt\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \nowidctlpar\s1\sb280\sa10\b\fs28\page #$K Presearch\par
\pard\b0\fs24\par
To avoid trying to path from a start point to a goal point when there can be NO PATH a \ldblquote presearch\rdblquote  has been implemented as of v1.20. The presearch is performed after any new map is loaded but before any pathing is done. It provides a way for any of the pathing algorithms to quickly check if there is any need in attempting to path the points.\par
\par
The concept as it occurred to me is fairly simple and seems to work. Basically, the master map in the Setup class has the field \ldblquote group\rdblquote  added to the world map. The presearch performs a series of floodfills against a map until everything is filled. Each floodfill action occurs with a unique group number. The end result is that you end up with a map consisting group ids for every point in the map. If the start point and end point both have the same group number, it is assumed that a path can be draw between the two points. Otherwise it is assumed the two points are isolated from each other by impassable terrain.\par
\par
}
 